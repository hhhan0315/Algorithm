## Part 5 동적 계획법
* [0. 입출력 속도 향상시키기](#0-입출력-속도-향상시키기)
* [1. 네트워크 선 자르기 (bottom-up)](#1-네트워크-선-자르기-bottom-up)
* [2. 네트워크 선 자르기 (top-down)](#2-네트워크-선-자르기-top-down)
* [4. 최대 부분 증가 수열 (LIS)](#4-최대-부분-증가-수열-lis)
* [5. 최대 선 연결하기 (LIS)](#5-최대-선-연결하기-lis)
* [6. 가장 높은 탑 쌓기 (LIS)](#6-가장-높은-탑-쌓기-lis)
* [7. 알리바바와 40인의 도둑 (bottom-up)](#7-알리바바와-40인의-도둑-bottom-up)
* [8. 알리바바와 40인의 도둑 (top-down)](#8-알리바바와-40인의-도둑-top-down)

[뒤로](https://github.com/hhhan0315/Algorithm)

### 0. 입출력 속도 향상시키기
```c
ios_base::sync_with_stdio(false);
	cin.tie(NULL);
```
[위로](#part-5-동적-계획법)

### 1. 네트워크 선 자르기 (bottom-up)
```c
#include <iostream>
using namespace std;

int main()
{
	int N;
	cin >> N;

	int dp[46];
	dp[1] = 1;	// 1m 하나
	dp[2] = 2;	// 2m 하나
	// dp[3] = 1+1, 2 = 2
	for (int i = 3; i <= N; i++)
	{
		dp[i] = dp[i - 2] + dp[i - 1];
	}
	cout << dp[N] << endl;

	return 0;
}
```
[위로](#part-5-동적-계획법)

### 2. 네트워크 선 자르기 (top-down)
```c
#include <iostream>
using namespace std;
int dp[46];

int dfs(int n)
{
	if (dp[n] > 0) return dp[n];	// 메모이제이션

	if (n == 1 || n == 2)
	{
		return n;
	}
	else
	{
		return dp[n] = dfs(n - 1) + dfs(n - 2);
	}
}

int main()
{
	int N;
	cin >> N;

	cout << dfs(N);

	return 0;
}
```
[위로](#part-5-동적-계획법)

### 4. 최대 부분 증가 수열 (LIS)
```c
#include <iostream>
using namespace std;
int arr[1001];
int dp[1001];

int main()
{
	int N, res = 0;
	cin >> N;
	for (int i = 1; i <= N; i++)
	{
		cin >> arr[i];
	}

	// 꼼꼼하게 생각해보자.
	dp[1] = 1;
	for (int i = 2; i <= N; i++)
	{
		int max = 0;
		for (int j = i - 1; j >= 1; j--)
		{
			if (arr[j] < arr[i] && dp[j] > max)
			{
				max = dp[j];
			}
		}
		dp[i] = max + 1;
		if (dp[i] > res)
			res = dp[i];
	}
	cout << res << endl;

	return 0;
}
```
[위로](#part-5-동적-계획법)

### 5. 최대 선 연결하기 (LIS)
```c
// 4번과 마찬가지로 잘 읽어보면 동일한 문제
#include <iostream>
using namespace std;
int arr[1001];
int dp[1001];

int main()
{
	int N, res = 0;
	cin >> N;
	for (int i = 1; i <= N; i++)
	{
		cin >> arr[i];
	}

	dp[1] = 1;
	for (int i = 2; i <= N; i++)
	{
		int max = 0;
		for (int j = i - 1; j >= 1; j--)
		{
			if (arr[j] < arr[i] && dp[j] > max)
			{
				max = dp[j];
			}
		}
		dp[i] = max + 1;
		if (dp[i] > res)
			res = dp[i];
	}
	cout << res << endl;

	return 0;
}
```
[위로](#part-5-동적-계획법)

### 6. 가장 높은 탑 쌓기 (LIS)
```c

```
[위로](#part-5-동적-계획법)

### 7. 알리바바와 40인의 도둑 (bottom-up)
```c

```
[위로](#part-5-동적-계획법)

### 8. 알리바바와 40인의 도둑 (top-down)
```c

```
[위로](#part-5-동적-계획법)
