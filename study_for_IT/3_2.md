## Part 3 재귀, DFS, BFS
* [66. 경로 탐색 (방향그래프 인접 리스트)](#66-경로-탐색-방향그래프-인접-리스트)
* [67. 최소 비용 (DFS)](#67-최소-비용-dfs)
* [68. 최소 비용 (가중치 방향 그래프 인접 리스트)](#68-최소-비용-가중치-방향-그래프-인접-리스트)
* [69. 이진트리 넓이 우선 탐색 (큐)](#69-이진트리-넓이-우선-탐색-큐)
* [70. 그래프 최단 거리 (BFS)](#70-그래프-최단-거리-bfs)
* [71. 송아지 찾기 (BFS)](#71-송아지-찾기-bfs)
* [72. 공주 구하기 (큐)](#72-공주-구하기-큐)
* [73. 최대 힙 (우선 순위 큐)](#73-최대-힙-우선-순위-큐)
* [74. 최소 힙 (우선 순위 큐)](#74-최소-힙-우선-순위-큐)
* [75. 최대 수입 스케쥴 (priority queue greedy)](#75-최대-수입-스케쥴-priority-queue-greedy)

[뒤로](https://github.com/hhhan0315/Algorithm)

### 66. 경로 탐색 (방향그래프 인접 리스트)
```c
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int visited[21], cnt = 0, N;
vector<int> map[21];

void dfs(int v)
{
	if (v == N)
	{
		cnt++;
	}
	else
	{
		for (int i = 0; i < map[v].size(); i++)
		{
			if (visited[map[v][i]] == 0)
			{	
				visited[map[v][i]] = 1;
				dfs(map[v][i]);
				visited[map[v][i]] = 0;
			}
		}
	}
}

int main()
{
	int M, a, b;
	cin >> N >> M;
	for (int i = 0; i < M; i++)
	{
		cin >> a >> b;
		map[a].push_back(b);
	}

	visited[1] = 1;
	dfs(1);
	cout << cnt << endl;

	return 0;
}
```
![3_2_1](https://github.com/hhhan0315/Algorithm/blob/master/study_for_IT/image/3_2_1.jpg)
[위로](#part-3-재귀-dfs-bfs)

### 67. 최소 비용 (DFS)
```c
#include <iostream>
#include <vector>
#include <algorithm>
#include <limits>
using namespace std;
int map[21][21], visited[21], N, min_num = INT_MAX;

void dfs(int v, int sum)
{
	if (v == N)
	{
		if (sum < min_num)
			min_num = sum;
	}
	else
	{
		for (int i = 1; i <= N; i++)
		{
			if (map[v][i] != 0 && visited[i] == 0)
			{
				visited[i] = 1;
				//sum += map[v][i];
				//dfs(i, sum);
				dfs(i, sum + map[v][i]);
				visited[i] = 0;
				//sum -= map[v][i];
			}
		}
	}
}

int main()
{
	int M, a, b, c;
	cin >> N >> M;
	for (int i = 0; i < M; i++)
	{
		cin >> a >> b >> c;
		map[a][b] = c;
	}

	visited[1] = 1;
	dfs(1, 0);
	cout << min_num << endl;

	return 0;
}
```
[위로](#part-3-재귀-dfs-bfs)

### 68. 최소 비용 (가중치 방향 그래프 인접 리스트)
```c
#include <iostream>
#include <vector>
#include <algorithm>
#include <limits>
using namespace std;
int visited[21], N, min_num = INT_MAX;
vector <pair<int, int> > map[21];

void dfs(int v, int sum)
{
	if (v == N)
	{
		if (sum < min_num)
			min_num = sum;
	}
	else
	{
		for (int i = 0; i < map[v].size(); i++)
		{
			if (visited[map[v][i].first] == 0)
			{
				visited[map[v][i].first] = 1;
				dfs(map[v][i].first, sum + map[v][i].second);
				visited[map[v][i].first] = 0;
			}
		}
	}
}

int main()
{
	int M, a, b, c;
	cin >> N >> M;
	for (int i = 0; i < M; i++)
	{
		cin >> a >> b >> c;
		map[a].push_back({ b,c });
		//map[a].push_back(make_pair(b, c));
	}

	visited[1] = 1;
	dfs(1, 0);
	cout << min_num << endl;

	return 0;
}
```
[위로](#part-3-재귀-dfs-bfs)

### 69. 이진트리 넓이 우선 탐색 (큐)
```c

```
[위로](#part-3-재귀-dfs-bfs)

### 70. 그래프 최단 거리 (BFS)
```c

```
[위로](#part-3-재귀-dfs-bfs)

### 71. 송아지 찾기 (BFS)
```c

```
[위로](#part-3-재귀-dfs-bfs)

### 72. 공주 구하기 (큐)
```c

```
[위로](#part-3-재귀-dfs-bfs)

### 73. 최대 힙 (우선 순위 큐)
```c

```
[위로](#part-3-재귀-dfs-bfs)

### 74. 최소 힙 (우선 순위 큐)
```c

```
[위로](#part-3-재귀-dfs-bfs)

### 75. 최대 수입 스케쥴 (priority queue greedy)
```c

```
[위로](#part-3-재귀-dfs-bfs)
