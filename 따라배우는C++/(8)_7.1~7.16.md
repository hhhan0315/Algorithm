## 7.2 값에 의한 전달 call by value
```c
#include <iostream>
using namespace std;

void doSomething(int y)
{
	cout << "In func " << y << " " << &y << endl;
	// 값을 전달해서 주소가 다르기 때문에 밖에서는 영향을 주지 않는다.
}

int main()
{
	doSomething(5);
	int x = 6;
	cout << "In main " << x << " " << &x << endl;

	doSomething(x);
	doSomething(x + 1);

	// func와 main의 주소는 다르다.

	return 0;
}
```

## 7.3 참조에 의한 인수 전달 call by reference
```c
#include <iostream>
using namespace std;

// reference라서 주소가 같고 밖에도 영향이 있다.
void foo(const int& y)	// const 사용하면 입력이라는 의미(값 변화 불가)
{
	cout << y << endl;
}

typedef int* pint;
//void foo2(int*& ptr)
void foo2(pint& ptr)	// 포인터 변수를 reference로 받는다.
{
	cout << ptr << endl;
}

int main()
{
	foo(5);

	int x = 5;
	int* ptr = &x;
	foo2(ptr);

	return 0;
}
// 참조에 의한 전달을 주로 잘 사용.
```

## 7.4 주소에 의한 인수 전달 call by address
```c
#include <iostream>
using namespace std;

void foo(int* ptr)	// 주소가 다르다. (포인터의 주소도 존재해서)
{
	cout << *ptr << " " << ptr << " " << &ptr << endl;
}
// 주소값이 전달되고 있다. (내부적으로는 값에 의한 전달)

int main()
{
	int value = 5;
	cout << value << " " << &value << endl;
	int* ptr = &value;
	cout << &ptr << endl;

	foo(ptr);
	foo(&value);

	return 0;
}
```

## 7
